export const dumpQueries: import('eslint-plugin-mmkal').CodegenPreset = ({dependencies: {fs, path}, context, meta}) => {
  const queriesDir = path.join(context.cwd, 'queries/pg/sql')
  const queries = fs
    .readdirSync(queriesDir)
    .filter(file => file.endsWith('.sql'))
    .map(filename => {
      const filepath = path.join(queriesDir, filename)
      const content = fs.readFileSync(filepath, 'utf8')
      return {filepath, filename, content}
    })

  const result =
    'export const queries = ' + JSON.stringify(Object.fromEntries(queries.map(q => [q.filename, q.content])), null, 2)

  if (result.replaceAll(/\s/g, '') === meta.existingContent.replaceAll(/\s/g, '')) {
    return meta.existingContent
  }

  return result
}

/** The source-of-truth for these queries are the contents of ../queries. Below they are dumped using eslint-plugin-codegen so they can be used in bundled contexts without worrying about relative files */
/* eslint-disable prettier/prettier */
// codegen:start {preset: custom, export: dumpQueries, require: tsx/cjs, dev: true}
export const queries = {
  "collations.sql": "select\n  collname as name,\n  n.nspname as schema,\n  case collprovider\n    when 'd' then 'database default'\n    when 'i' then 'icu'\n    when 'c' then 'libc'\n  end\n  as provider,\n  collencoding as encoding,\n  collcollate as lc_collate,\n  collctype as lc_ctype,\n  collversion as version\nfrom\npg_collation c\nINNER JOIN pg_namespace n\n    ON n.oid=c.collnamespace\n    -- SKIP_INTERNAL where nspname not in ('pg_internal', 'pg_catalog', 'information_schema', 'pg_toast')\n    -- SKIP_INTERNAL and nspname not like 'pg_temp_%' and nspname not like 'pg_toast_temp_%'\norder by 2, 1\n",
  "collations9.sql": "select\n  collname as name,\n  n.nspname as schema,\n  'd' as provider,\n  collencoding as encoding,\n  collcollate as lc_collate,\n  collctype as lc_ctype,\n  null as version\nfrom\npg_collation c\nINNER JOIN pg_namespace n\n    ON n.oid=c.collnamespace\n    -- SKIP_INTERNAL where nspname not in ('pg_internal', 'pg_catalog', 'information_schema', 'pg_toast')\n    -- SKIP_INTERNAL and nspname not like 'pg_temp_%' and nspname not like 'pg_toast_temp_%'\norder by 2, 1\n",
  "constraints.sql": "with information_schema_table_constraints as (\nselect\n    nc.nspname::information_schema.sql_identifier AS constraint_schema,\n    c.conname::information_schema.sql_identifier AS constraint_name,\n    nr.nspname::information_schema.sql_identifier AS table_schema,\n    r.relname::information_schema.sql_identifier AS table_name,\n    CASE c.contype\n        WHEN 'c'::\"char\" THEN 'CHECK'::text\n        WHEN 'f'::\"char\" THEN 'FOREIGN KEY'::text\n        WHEN 'p'::\"char\" THEN 'PRIMARY KEY'::text\n        WHEN 'u'::\"char\" THEN 'UNIQUE'::text\n        ELSE NULL::text\n    END::information_schema.character_data AS constraint_type,\n    CASE\n        WHEN c.condeferrable THEN 'YES'::text\n        ELSE 'NO'::text\n    END::information_schema.yes_or_no AS is_deferrable,\n    CASE\n        WHEN c.condeferred THEN 'YES'::text\n        ELSE 'NO'::text\n    END::information_schema.yes_or_no AS initially_deferred,\n    'YES'::character varying::information_schema.yes_or_no AS enforced\n   FROM pg_namespace nc,\n    pg_namespace nr,\n    pg_constraint c,\n    pg_class r\n  WHERE nc.oid = c.connamespace AND nr.oid = r.relnamespace AND c.conrelid = r.oid AND (c.contype <> ALL (ARRAY['t'::\"char\", 'x'::\"char\"])) AND (r.relkind = ANY (ARRAY['r'::\"char\", 'p'::\"char\"])) AND NOT pg_is_other_temp_schema(nr.oid) AND (pg_has_role(r.relowner, 'USAGE'::text) OR has_table_privilege(r.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(r.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text))\nUNION ALL\n SELECT\n    nr.nspname::information_schema.sql_identifier AS constraint_schema,\n    (((((nr.oid::text || '_'::text) || r.oid::text) || '_'::text) || a.attnum::text) || '_not_null'::text)::information_schema.sql_identifier AS constraint_name,\n    nr.nspname::information_schema.sql_identifier AS table_schema,\n    r.relname::information_schema.sql_identifier AS table_name,\n    'CHECK'::character varying::information_schema.character_data AS constraint_type,\n    'NO'::character varying::information_schema.yes_or_no AS is_deferrable,\n    'NO'::character varying::information_schema.yes_or_no AS initially_deferred,\n    'YES'::character varying::information_schema.yes_or_no AS enforced\n   FROM pg_namespace nr,\n    pg_class r,\n    pg_attribute a\n  WHERE nr.oid = r.relnamespace AND r.oid = a.attrelid AND a.attnotnull AND a.attnum > 0 AND NOT a.attisdropped AND (r.relkind = ANY (ARRAY['r'::\"char\", 'p'::\"char\"])) AND NOT pg_is_other_temp_schema(nr.oid) AND (pg_has_role(r.relowner, 'USAGE'::text) OR has_table_privilege(r.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR has_any_column_privilege(r.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text))\n),\nextension_oids as (\n  select\n      objid\n  from\n      pg_depend d\n  WHERE\n      d.refclassid = 'pg_extension'::regclass\n      and d.classid = 'pg_constraint'::regclass\n), extension_rels as (\n  select\n      objid\n  from\n      pg_depend d\n  WHERE\n      d.refclassid = 'pg_extension'::regclass\n      and d.classid = 'pg_class'::regclass\n), indexes as (\n    select\n        schemaname as schema,\n        tablename as table_name,\n        indexname as name,\n        indexdef as definition,\n        indexdef as create_statement\n    FROM\n        pg_indexes\n        -- SKIP_INTERNAL where schemaname not in ('pg_catalog', 'information_schema', 'pg_toast')\n\t\t-- SKIP_INTERNAL and schemaname not like 'pg_temp_%' and schemaname not like 'pg_toast_temp_%'\n    order by\n        schemaname, tablename, indexname\n)\nselect\n    nspname as schema,\n    conname as name,\n    relname as table_name,\n    pg_get_constraintdef(pg_constraint.oid) as definition,\n    case contype\n        when 'c' then 'CHECK'\n        when 'f' then 'FOREIGN KEY'\n        when 'p' then 'PRIMARY KEY'\n        when 'u' then 'UNIQUE'\n        when 'x' then 'EXCLUDE'\n    end as constraint_type,\n    i.name as index,\n    e.objid as extension_oid,\n    case when contype = 'f' then\n        (\n            SELECT nspname\n            FROM pg_catalog.pg_class AS c\n            JOIN pg_catalog.pg_namespace AS ns\n            ON c.relnamespace = ns.oid\n            WHERE c.oid = confrelid::regclass\n        )\n    end as foreign_table_schema,\n    case when contype = 'f' then\n        (\n            select relname\n            from pg_catalog.pg_class c\n            where c.oid = confrelid::regclass\n        )\n    end as foreign_table_name,\n    case when contype = 'f' then\n        (\n            select\n                array_agg(ta.attname order by c.rn)\n            from\n            pg_attribute ta\n            join unnest(conkey) with ordinality c(cn, rn)\n\n            on\n                ta.attrelid = conrelid and ta.attnum = c.cn\n        )\n    else null end as fk_columns_local,\n    case when contype = 'f' then\n        (\n            select\n                array_agg(ta.attname order by c.rn)\n            from\n            pg_attribute ta\n            join unnest(confkey) with ordinality c(cn, rn)\n\n            on\n                ta.attrelid = confrelid and ta.attnum = c.cn\n        )\n    else null end as fk_columns_foreign,\n    contype = 'f' as is_fk,\n    condeferrable as is_deferrable,\n    condeferred as initially_deferred\nfrom\n    pg_constraint\n    INNER JOIN pg_class\n        ON conrelid=pg_class.oid\n    INNER JOIN pg_namespace\n        ON pg_namespace.oid=pg_class.relnamespace\n    left outer join indexes i\n        on nspname = i.schema\n        and conname = i.name\n        and relname = i.table_name\n    left outer join extension_oids e\n      on pg_class.oid = e.objid\n    left outer join extension_rels er\n      on er.objid = conrelid\n    left outer join extension_rels cr\n      on cr.objid = confrelid\n    where contype in ('c', 'f', 'p', 'u', 'x')\n  -- SKIP_INTERNAL and nspname not in ('pg_internal', 'pg_catalog', 'information_schema', 'pg_toast', 'pg_temp_1', 'pg_toast_temp_1')\n  -- SKIP_INTERNAL and e.objid is null and er.objid is null and cr.objid is null\norder by 1, 3, 2;\n",
  "deps.sql": "\nwith things1 as (\n  select\n    oid as objid,\n    pronamespace as namespace,\n    proname as name,\n    pg_get_function_identity_arguments(oid) as identity_arguments,\n    'f' as kind\n  from pg_proc\n  -- 11_AND_LATER where pg_proc.prokind != 'a'\n  -- 10_AND_EARLIER where pg_proc.proisagg is False\n  union\n  select\n    oid,\n    relnamespace as namespace,\n    relname as name,\n    null as identity_arguments,\n    relkind as kind\n  from pg_class\n  where oid not in (\n    select ftrelid from pg_foreign_table\n  )\n),\nextension_objids as (\n  select\n      objid as extension_objid\n  from\n      pg_depend d\n  WHERE\n      d.refclassid = 'pg_extension'::regclass\n    union\n    select\n        t.typrelid as extension_objid\n    from\n        pg_depend d\n        join pg_type t on t.oid = d.objid\n    where\n        d.refclassid = 'pg_extension'::regclass\n),\nthings as (\n    select\n      objid,\n      kind,\n      n.nspname as schema,\n      name,\n      identity_arguments\n    from things1 t\n    inner join pg_namespace n\n      on t.namespace = n.oid\n    left outer join extension_objids\n      on t.objid = extension_objids.extension_objid\n    where\n      kind in ('r', 'v', 'm', 'c', 'f') and\n      nspname not in ('pg_internal', 'pg_catalog', 'information_schema', 'pg_toast')\n      and nspname not like 'pg_temp_%' and nspname not like 'pg_toast_temp_%'\n      and extension_objids.extension_objid is null\n),\ncombined as (\n  select distinct\n    t.objid,\n    t.schema,\n    t.name,\n    t.identity_arguments,\n    t.kind,\n    things_dependent_on.objid as objid_dependent_on,\n    things_dependent_on.schema as schema_dependent_on,\n    things_dependent_on.name as name_dependent_on,\n    things_dependent_on.identity_arguments as identity_arguments_dependent_on,\n    things_dependent_on.kind as kind_dependent_on\n  FROM\n      pg_depend d\n      inner join things things_dependent_on\n        on d.refobjid = things_dependent_on.objid\n      inner join pg_rewrite rw\n        on d.objid = rw.oid\n        and things_dependent_on.objid != rw.ev_class\n      inner join things t\n        on rw.ev_class = t.objid\n  where\n    d.deptype in ('n')\n    and\n    rw.rulename = '_RETURN'\n)\nselect * from combined\norder by\nschema, name, identity_arguments, kind_dependent_on,\nschema_dependent_on, name_dependent_on, identity_arguments_dependent_on\n",
  "domains.sql": "with extension_oids as (\n  select\n      objid\n  from\n      pg_depend d\n  WHERE\n      d.refclassid = 'pg_extension'::regclass and\n      d.classid = 'pg_type'::regclass\n)\nSELECT n.nspname as \"schema\",\n       t.typname as \"name\",\n       pg_catalog.format_type(t.typbasetype, t.typtypmod) as \"data_type\",\n       (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type bt\n        WHERE c.oid = t.typcollation AND bt.oid = t.typbasetype AND t.typcollation <> bt.typcollation) as \"collation\",\n        rr.conname as \"constraint_name\",\n       t.typnotnull as \"not_null\",\n       t.typdefault as \"default\",\n       pg_catalog.array_to_string(ARRAY(\n         SELECT pg_catalog.pg_get_constraintdef(r.oid, true) FROM pg_catalog.pg_constraint r WHERE t.oid = r.contypid\n       ), ' ') as \"check\"\nFROM pg_catalog.pg_type t\n     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\n     left join pg_catalog.pg_constraint rr on t.oid = rr.contypid\nWHERE t.typtype = 'd'\n      AND n.nspname <> 'pg_catalog'\n      AND n.nspname <> 'information_schema'\n  AND pg_catalog.pg_type_is_visible(t.oid)\n  and t.oid not in (select * from extension_oids)\nORDER BY 1, 2;\n",
  "enums.sql": "with extension_oids as (\n  select\n      objid\n  from\n      pg_depend d\n  WHERE\n      d.refclassid = 'pg_extension'::regclass and\n      d.classid = 'pg_type'::regclass\n)\nSELECT\n  n.nspname as \"schema\",\n  t.typname as \"name\",\n  ARRAY(\n     SELECT e.enumlabel\n      FROM pg_catalog.pg_enum e\n      WHERE e.enumtypid = t.oid\n      ORDER BY e.enumsortorder\n  ) as elements\nFROM pg_catalog.pg_type t\n     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\n     left outer join extension_oids e\n       on t.oid = e.objid\nWHERE\n  t.typcategory = 'E'\n  and e.objid is null\n  -- SKIP_INTERNAL and n.nspname not in ('pg_internal', 'pg_catalog', 'information_schema', 'pg_toast')\n  -- SKIP_INTERNAL and n.nspname not like 'pg_temp_%' and n.nspname not like 'pg_toast_temp_%'\nORDER BY 1, 2;\n",
  "extensions.sql": "select\n  nspname as schema,\n  extname as name,\n  extversion as version,\n  e.oid as oid\nfrom\n    pg_extension e\n    INNER JOIN pg_namespace\n        ON pg_namespace.oid=e.extnamespace\norder by schema, name;\n",
  "functions.sql": "with extension_oids as (\n      select\n          objid\n      from\n          pg_depend d\n      WHERE\n          d.refclassid = 'pg_extension'::regclass\n          and d.classid = 'pg_proc'::regclass\n    ),\n    pg_proc_pre as (\n      select\n        pp.*,\n        -- 11_AND_LATER pp.oid as p_oid\n        -- 10_AND_EARLIER pp.oid as p_oid, case when pp.proisagg then 'a' else 'f' end as prokind\n      from pg_proc pp\n    ),\nroutines as (\n SELECT current_database()::information_schema.sql_identifier AS specific_catalog,\n    n.nspname::information_schema.sql_identifier AS specific_schema,\n    --nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name,\n    current_database()::information_schema.sql_identifier AS routine_catalog,\n    n.nspname::information_schema.sql_identifier AS schema,\n    p.proname::information_schema.sql_identifier AS name,\n        CASE p.prokind\n            WHEN 'f'::\"char\" THEN 'FUNCTION'::text\n            WHEN 'p'::\"char\" THEN 'PROCEDURE'::text\n            ELSE NULL::text\n        END::information_schema.character_data AS routine_type,\n        CASE\n            WHEN p.prokind = 'p'::\"char\" THEN NULL::text\n            WHEN t.typelem <> 0::oid AND t.typlen = '-1'::integer THEN 'ARRAY'::text\n            WHEN nt.nspname = 'pg_catalog'::name THEN format_type(t.oid, NULL::integer)\n            ELSE 'USER-DEFINED'::text\n        END::information_schema.character_data AS data_type,\n\n        CASE\n            WHEN nt.nspname IS NOT NULL THEN current_database()\n            ELSE NULL::name\n        END::information_schema.sql_identifier AS type_udt_catalog,\n    nt.nspname::information_schema.sql_identifier AS type_udt_schema,\n    t.typname::information_schema.sql_identifier AS type_udt_name,\n        CASE\n            WHEN p.prokind <> 'p'::\"char\" THEN 0\n            ELSE NULL::integer\n        END::information_schema.sql_identifier AS dtd_identifier,\n        CASE\n            WHEN l.lanname = 'sql'::name THEN 'SQL'::text\n            ELSE 'EXTERNAL'::text\n        END::information_schema.character_data AS routine_body,\n        CASE\n            WHEN pg_has_role(p.proowner, 'USAGE'::text) THEN p.prosrc\n            ELSE NULL::text\n        END::information_schema.character_data AS definition,\n        CASE\n            WHEN l.lanname = 'c'::name THEN p.prosrc\n            ELSE NULL::text\n        END::information_schema.character_data AS external_name,\n    upper(l.lanname::text)::information_schema.character_data AS external_language,\n    'GENERAL'::character varying::information_schema.character_data AS parameter_style,\n        CASE\n            WHEN p.provolatile = 'i'::\"char\" THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_deterministic,\n    'MODIFIES'::character varying::information_schema.character_data AS sql_data_access,\n        CASE\n            WHEN p.prokind <> 'p'::\"char\" THEN\n            CASE\n                WHEN p.proisstrict THEN 'YES'::text\n                ELSE 'NO'::text\n            END\n            ELSE NULL::text\n        END::information_schema.yes_or_no AS is_null_call,\n    'YES'::character varying::information_schema.yes_or_no AS schema_level_routine,\n    0::information_schema.cardinal_number AS max_dynamic_result_sets,\n        CASE\n            WHEN p.prosecdef THEN 'DEFINER'::text\n            ELSE 'INVOKER'::text\n        END::information_schema.character_data AS security_type,\n    'NO'::character varying::information_schema.yes_or_no AS as_locator,\n    'NO'::character varying::information_schema.yes_or_no AS is_udt_dependent,\n    p.p_oid as oid,\n    p.proisstrict,\n    p.prosecdef,\n    p.provolatile,\n    p.proargtypes,\n    p.proallargtypes,\n    p.proargnames,\n    p.proargdefaults,\n    p.proargmodes,\n    p.proowner,\n    p.prokind as kind\n   FROM pg_namespace n\n     JOIN pg_proc_pre p ON n.oid = p.pronamespace\n     JOIN pg_language l ON p.prolang = l.oid\n     LEFT JOIN (pg_type t\n     JOIN pg_namespace nt ON t.typnamespace = nt.oid) ON p.prorettype = t.oid AND p.prokind <> 'p'::\"char\"\n  WHERE pg_has_role(p.proowner, 'USAGE'::text) OR has_function_privilege(p.p_oid, 'EXECUTE'::text)\n\n),\n    pgproc as (\n      select\n        schema,\n        name,\n        p.oid as oid,\n        e.objid as extension_oid,\n        case proisstrict when true then\n          'RETURNS NULL ON NULL INPUT'\n        else\n          'CALLED ON NULL INPUT'\n        end as strictness,\n        case prosecdef when true then\n          'SECURITY DEFINER'\n        else\n          'SECURITY INVOKER'\n        end as security_type,\n        case provolatile\n          when 'i' then\n            'IMMUTABLE'\n          when 's' then\n            'STABLE'\n          when 'v' then\n            'VOLATILE'\n          else\n            null\n        end as volatility,\n        p.proargtypes,\n        p.proallargtypes,\n        p.proargnames,\n        p.proargdefaults,\n        p.proargmodes,\n        p.proowner,\n        COALESCE(p.proallargtypes, p.proargtypes::oid[]) as procombinedargtypes,\n        p.kind,\n        p.type_udt_schema,\n        p.type_udt_name,\n        p.definition,\n        p.external_language\n\n      from\n          routines p\n          left outer join extension_oids e\n            on p.oid = e.objid\n      where true\n      -- 11_AND_LATER and p.kind != 'a'\n      -- SKIP_INTERNAL and schema not in ('pg_internal', 'pg_catalog', 'information_schema', 'pg_toast')\n      -- SKIP_INTERNAL and schema not like 'pg_temp_%' and schema not like 'pg_toast_temp_%'\n      -- SKIP_INTERNAL and e.objid is null\n      -- SKIP_INTERNAL and p.external_language not in ('C', 'INTERNAL')\n    ),\nunnested as (\n    select\n        p.*,\n        pname as parameter_name,\n        pnum as position_number,\n        CASE\n            WHEN pargmode IS NULL THEN null\n            WHEN pargmode = 'i'::\"char\" THEN 'IN'::text\n            WHEN pargmode = 'o'::\"char\" THEN 'OUT'::text\n            WHEN pargmode = 'b'::\"char\" THEN 'INOUT'::text\n            WHEN pargmode = 'v'::\"char\" THEN 'IN'::text\n            WHEN pargmode = 't'::\"char\" THEN 'OUT'::text\n            ELSE NULL::text\n            END::information_schema.character_data AS parameter_mode,\n      CASE\n        WHEN t.typelem <> 0::oid AND t.typlen = '-1'::integer THEN 'ARRAY'::text\n        else format_type(t.oid, NULL::integer)\n\n    END::information_schema.character_data AS data_type,\n    CASE\n            WHEN pg_has_role(p.proowner, 'USAGE'::text) THEN pg_get_function_arg_default(p.oid, pnum::int)\n            ELSE NULL::text\n        END::varchar AS parameter_default\n    from pgproc p\n    left join lateral\n    unnest(\n        p.proargnames,\n        p.proallargtypes,\n        p.procombinedargtypes,\n        p.proargmodes)\n    WITH ORDINALITY AS uu(pname, pdatatype, pargtype, pargmode, pnum) ON TRUE\n    left join pg_type t\n        on t.oid = uu.pargtype\n),\n    pre as (\n        SELECT\n            p.schema as schema,\n            p.name as name,\n            case when p.data_type = 'USER-DEFINED' then\n              '\"' || p.type_udt_schema || '\".\"' || p.type_udt_name || '\"'\n            else\n              p.data_type\n            end as returntype,\n            p.data_type = 'USER-DEFINED' as has_user_defined_returntype,\n            p.parameter_name as parameter_name,\n            p.data_type as data_type,\n            p.parameter_mode as parameter_mode,\n            p.parameter_default as parameter_default,\n            p.position_number as position_number,\n            p.definition as definition,\n            pg_get_functiondef(p.oid) as full_definition,\n            p.external_language as language,\n            p.strictness as strictness,\n            p.security_type as security_type,\n            p.volatility as volatility,\n            p.kind as kind,\n            p.oid as oid,\n            p.extension_oid as extension_oid,\n            pg_get_function_result(p.oid) as result_string,\n            pg_get_function_identity_arguments(p.oid) as identity_arguments,\n            pg_catalog.obj_description(p.oid) as comment\n        FROM\n          unnested p\n    )\nselect\n*\nfrom pre\norder by\n    schema, name, parameter_mode, position_number, parameter_name;\n",
  "indexes.sql": "with extension_oids as (\n  select\n      objid,\n      classid::regclass::text as classid\n  from\n      pg_depend d\n  WHERE\n      d.refclassid = 'pg_extension'::regclass and\n      d.classid = 'pg_index'::regclass\n),\nextension_relations as (\n  select\n      objid\n  from\n      pg_depend d\n  WHERE\n      d.refclassid = 'pg_extension'::regclass and\n      d.classid = 'pg_class'::regclass\n), pre as (\n    SELECT n.nspname AS schema,\n   c.relname AS table_name,\n   i.relname AS name,\n   i.oid as oid,\n   e.objid as extension_oid,\n   pg_get_indexdef(i.oid) AS definition,\n       (\n           select\n               array_agg(attname order by ik.n)\n           from\n                unnest(x.indkey) with ordinality ik(i, n)\n                join pg_attribute aa\n                    on\n                        aa.attrelid = x.indrelid\n                        and ik.i = aa.attnum\n        )\n       index_columns,\n       indoption key_options,\n       indnatts total_column_count,\n       -- 11_AND_LATER indnkeyatts key_column_count,\n       -- 10_AND_EARLIER indnatts key_column_count,\n       indnatts num_att,\n        -- 11_AND_LATER indnatts - indnkeyatts included_column_count,\n        -- 10_AND_EARLIER 0 included_column_count,\n       indisunique is_unique,\n       indisprimary is_pk,\n       indisexclusion is_exclusion,\n       indimmediate is_immediate,\n       indisclustered is_clustered,\n       indcollation key_collations,\n       pg_get_expr(indexprs, indrelid) key_expressions,\n       pg_get_expr(indpred, indrelid) partial_predicate,\n       amname algorithm\n  FROM pg_index x\n    JOIN pg_class c ON c.oid = x.indrelid\n    JOIN pg_class i ON i.oid = x.indexrelid\n    JOIN pg_am am ON i.relam = am.oid\n    LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\n     left join extension_oids e\n      on i.oid = e.objid\n    left join extension_relations er\n      on c.oid = er.objid\nWHERE\n    x.indislive\n    and c.relkind in ('r', 'm', 'p') AND i.relkind in ('i', 'I')\n      -- SKIP_INTERNAL and nspname not in ('pg_catalog', 'information_schema', 'pg_toast')\n      -- SKIP_INTERNAL and nspname not like 'pg_temp_%' and nspname not like 'pg_toast_temp_%'\n      -- SKIP_INTERNAL and e.objid is null and er.objid is null\n)\nselect * ,\nindex_columns[1\\:key_column_count] as key_columns,\nindex_columns[key_column_count+1\\:array_length(index_columns, 1)] as included_columns\nfrom pre\norder by 1, 2, 3;\n",
  "privileges.sql": "select\n  table_schema as schema,\n  table_name as name,\n  'table' as object_type,\n  grantee as user,\n  privilege_type as privilege\nfrom information_schema.role_table_grants\nwhere grantee != (\n    select tableowner\n    from pg_tables\n    where schemaname = table_schema\n    and tablename = table_name\n)\n-- SKIP_INTERNAL and table_schema not in ('pg_internal', 'pg_catalog', 'information_schema', 'pg_toast')\n-- SKIP_INTERNAL and table_schema not like 'pg_temp_%' and table_schema not like 'pg_toast_temp_%'\norder by schema, name, user;\n",
  "relations.sql": "with extension_oids as (\n  select\n      objid\n  from\n      pg_depend d\n  WHERE\n      d.refclassid = 'pg_extension'::regclass and\n      d.classid = 'pg_class'::regclass\n), enums as (\n\n  SELECT\n    t.oid as enum_oid,\n    n.nspname as \"schema\",\n    t.typname as name\n  FROM pg_catalog.pg_type t\n       LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\n       left outer join extension_oids e\n         on t.oid = e.objid\n  WHERE\n    t.typcategory = 'E'\n    and e.objid is null\n    -- SKIP_INTERNAL and n.nspname not in ('pg_catalog', 'information_schema', 'pg_toast')\n    -- SKIP_INTERNAL and n.nspname not like 'pg_temp_%' and n.nspname not like 'pg_toast_temp_%'\n  ORDER BY 1, 2\n),\nr as (\n    select\n        c.relname as name,\n        n.nspname as schema,\n        c.relkind as relationtype,\n        c.oid as oid,\n        case when c.relkind in ('m', 'v') then\n          pg_get_viewdef(c.oid)\n        else null end\n          as definition,\n        (SELECT\n              '\"' || nmsp_parent.nspname || '\".\"' || parent.relname || '\"' as parent\n          FROM pg_inherits\n              JOIN pg_class parent            ON pg_inherits.inhparent = parent.oid\n              JOIN pg_class child             ON pg_inherits.inhrelid   = child.oid\n              JOIN pg_namespace nmsp_parent   ON nmsp_parent.oid  = parent.relnamespace\n              JOIN pg_namespace nmsp_child    ON nmsp_child.oid   = child.relnamespace\n          where child.oid = c.oid)\n        as parent_table,\n        case when c.relpartbound is not null then\n          pg_get_expr(c.relpartbound, c.oid, true)\n        when c.relhassubclass is not null then\n          pg_catalog.pg_get_partkeydef(c.oid)\n        end\n        as partition_def,\n        c.relrowsecurity::boolean as rowsecurity,\n        c.relforcerowsecurity::boolean as forcerowsecurity,\n        c.relpersistence as persistence,\n        c.relpages as page_size_estimate,\n        c.reltuples as row_count_estimate\n    from\n        pg_catalog.pg_class c\n        inner join pg_catalog.pg_namespace n\n          ON n.oid = c.relnamespace\n        left outer join extension_oids e\n          on c.oid = e.objid\n    where c.relkind in ('r', 'v', 'm', 'c', 'p')\n    -- SKIP_INTERNAL and e.objid is null\n    -- SKIP_INTERNAL and n.nspname not in ('pg_catalog', 'information_schema', 'pg_toast')\n    -- SKIP_INTERNAL and n.nspname not like 'pg_temp_%' and n.nspname not like 'pg_toast_temp_%'\n)\nselect\n    r.relationtype,\n    r.schema,\n    r.name,\n    r.definition as definition,\n    a.attnum as position_number,\n    a.attname as attname,\n    a.attnotnull as not_null,\n    a.atttypid::regtype AS datatype,\n    a.attidentity != '' as is_identity,\n    a.attidentity = 'a' as is_identity_always,\n    -- PRE_12 false as is_generated,\n    -- 12_ONLY a.attgenerated != '' as is_generated,\n    (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t\n     WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS collation,\n    pg_get_expr(ad.adbin, ad.adrelid) as defaultdef,\n    r.oid as oid,\n    format_type(atttypid, atttypmod) AS datatypestring,\n    e.enum_oid is not null as is_enum,\n    e.name as enum_name,\n    e.schema as enum_schema,\n    pg_catalog.obj_description(r.oid) as comment,\n    r.parent_table,\n    r.partition_def,\n    r.rowsecurity,\n    r.forcerowsecurity,\n    r.persistence,\n    r.page_size_estimate,\n    r.row_count_estimate\nFROM\n    r\n    left join pg_catalog.pg_attribute a\n        on r.oid = a.attrelid and a.attnum > 0\n    left join pg_catalog.pg_attrdef ad\n        on a.attrelid = ad.adrelid\n        and a.attnum = ad.adnum\n    left join enums e\n      on a.atttypid = e.enum_oid\nwhere a.attisdropped is not true\n-- SKIP_INTERNAL and r.schema not in ('pg_catalog', 'information_schema', 'pg_toast')\n-- SKIP_INTERNAL and r.schema not like 'pg_temp_%' and r.schema not like 'pg_toast_temp_%'\norder by relationtype, r.schema, r.name, position_number;\n",
  "relations9.sql": "with extension_oids as (\n  select\n      objid\n  from\n      pg_depend d\n  WHERE\n      d.refclassid = 'pg_extension'::regclass\n), enums as (\n\n  SELECT\n    t.oid as enum_oid,\n    n.nspname as \"schema\",\n    pg_catalog.format_type(t.oid, NULL) AS \"name\"\n  FROM pg_catalog.pg_type t\n       LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\n       left outer join extension_oids e\n         on t.oid = e.objid\n  WHERE\n    t.typcategory = 'E'\n    and e.objid is null\n    -- SKIP_INTERNAL and n.nspname not in ('pg_catalog', 'information_schema', 'pg_toast')\n    -- SKIP_INTERNAL and n.nspname not like 'pg_temp_%' and n.nspname not like 'pg_toast_temp_%'\n    AND pg_catalog.pg_type_is_visible(t.oid)\n  ORDER BY 1, 2\n),\nr as (\n    select\n        c.relname as name,\n        n.nspname as schema,\n        c.relkind as relationtype,\n        c.oid as oid,\n        case when c.relkind in ('m', 'v') then\n          pg_get_viewdef(c.oid)\n        else null end\n          as definition,\n        null\n        as parent_table,\n        null as partition_def,\n        c.relrowsecurity::boolean as rowsecurity,\n        c.relforcerowsecurity::boolean as forcerowsecurity,\n        c.relpersistence as persistence,\n        c.relpages as page_size_estimate,\n        c.reltuples as row_count_estimate\n    from\n        pg_catalog.pg_class c\n        inner join pg_catalog.pg_namespace n\n          ON n.oid = c.relnamespace\n        left outer join extension_oids e\n          on c.oid = e.objid\n    where c.relkind in ('r', 'v', 'm', 'c', 'p')\n    -- SKIP_INTERNAL and e.objid is null\n    -- SKIP_INTERNAL and n.nspname not in ('pg_catalog', 'information_schema', 'pg_toast')\n    -- SKIP_INTERNAL and n.nspname not like 'pg_temp_%' and n.nspname not like 'pg_toast_temp_%'\n)\nselect\n    r.relationtype,\n    r.schema,\n    r.name,\n    r.definition as definition,\n    a.attnum as position_number,\n    a.attname as attname,\n    a.attnotnull as not_null,\n    a.atttypid::regtype AS datatype,\n    false AS is_identity,\n    false as is_identity_always,\n    false as is_generated,\n    (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type t\n     WHERE c.oid = a.attcollation AND t.oid = a.atttypid AND a.attcollation <> t.typcollation) AS collation,\n    pg_get_expr(ad.adbin, ad.adrelid) as defaultdef,\n    r.oid as oid,\n    format_type(atttypid, atttypmod) AS datatypestring,\n    e.enum_oid is not null as is_enum,\n    e.name as enum_name,\n    e.schema as enum_schema,\n    pg_catalog.obj_description(r.oid) as comment,\n    r.parent_table,\n    r.partition_def,\n    r.rowsecurity,\n    r.forcerowsecurity,\n    r.persistence,\n    r.page_size_estimate,\n    r.row_count_estimate\nFROM\n    r\n    left join pg_catalog.pg_attribute a\n        on r.oid = a.attrelid and a.attnum > 0\n    left join pg_catalog.pg_attrdef ad\n        on a.attrelid = ad.adrelid\n        and a.attnum = ad.adnum\n    left join enums e\n      on a.atttypid = e.enum_oid\nwhere a.attisdropped is not true\n-- SKIP_INTERNAL and r.schema not in ('pg_catalog', 'information_schema', 'pg_toast')\n-- SKIP_INTERNAL and r.schema not like 'pg_temp_%' and r.schema not like 'pg_toast_temp_%'\norder by relationtype, r.schema, r.name, position_number;\n",
  "rlspolicies.sql": "select\n  p.polname as name,\n  n.nspname as schema,\n  c.relname as table_name,\n  p.polcmd as commandtype,\n  p.polpermissive as permissive,\n  (\n    select\n      array_agg(\n        case when o = 0 THEN\n        'public'\n        else\n        pg_get_userbyid(o)\n        end\n      )\n    from\n    unnest(p.polroles) as unn(o)\n  )\n  as roles,\n  p.polqual as qualtree,\n  pg_get_expr(p.polqual, p.polrelid) as qual,\n  pg_get_expr(p.polwithcheck, p.polrelid) as withcheck\nfrom\n  pg_policy p\n  join pg_class c ON c.oid = p.polrelid\n  JOIN pg_namespace n ON n.oid = c.relnamespace\norder by\n  2, 1\n",
  "schemas.sql": "with extension_oids as (\n  select\n      objid\n  from\n      pg_depend d\n  WHERE\n      d.refclassid = 'pg_extension'::regclass\n      and d.classid = 'pg_namespace'::regclass\n) select\n    nspname as schema\nfrom\n    pg_catalog.pg_namespace\n    left outer join extension_oids e\n    \ton e.objid = oid\n-- SKIP_INTERNAL where nspname not in ('pg_internal', 'pg_catalog', 'information_schema', 'pg_toast')\n-- SKIP_INTERNAL and nspname not like 'pg_temp_%' and nspname not like 'pg_toast_temp_%'\n-- SKIP_INTERNAL and e.objid is null\norder by 1;\n",
  "sequences.sql": "with\nextension_objids as (\n    select\n        objid as extension_objid\n    from\n        pg_depend d\n    WHERE\n        d.refclassid = 'pg_extension'::regclass and\n        d.classid = 'pg_class'::regclass\n), pre as (\n    select\n        n.nspname as schema,\n        c.relname as name,\n        c_ref.relname as table_name,\n        a.attname as column_name,\n        --a.attname is not null as has_table_owner,\n        --a.attidentity is distinct from '' as is_identity,\n        d.deptype is not distinct from 'i' as is_identity\n        --a.attidentity = 'a' as is_identity_always\n    from\n        --pg_sequence s\n\n        --inner join pg_class c\n        --    on s.seqrelid = c.oid\n\n        pg_class c\n\n        inner join pg_catalog.pg_namespace n\n            ON n.oid = c.relnamespace\n\n        left join extension_objids\n            on c.oid = extension_objids.extension_objid\n\n        left join pg_depend d\n            on c.oid = d.objid and d.deptype in ('i', 'a')\n\n        left join pg_class c_ref\n            on d.refobjid = c_ref.oid\n\n        left join pg_attribute a\n            ON ( a.attnum = d.refobjsubid\n                AND a.attrelid = d.refobjid )\n\nwhere\n    c.relkind = 'S'\n    -- SKIP_INTERNAL and n.nspname not in ('pg_internal', 'pg_catalog', 'information_schema', 'pg_toast')\n    -- SKIP_INTERNAL and n.nspname not like 'pg_temp_%' and n.nspname not like 'pg_toast_temp_%'\n    and extension_objids.extension_objid is null\n)\nselect\n    *\nfrom\n    pre\nwhere\n    not is_identity\norder by\n    1, 2;\n",
  "triggers.sql": "with extension_oids as (\n  select\n      objid\n  from\n      pg_depend d\n  WHERE\n     d.refclassid = 'pg_extension'::regclass and\n     d.classid = 'pg_trigger'::regclass\n)\nselect\n    tg.tgname \"name\",\n    nsp.nspname \"schema\",\n    cls.relname table_name,\n    pg_get_triggerdef(tg.oid) full_definition,\n    proc.proname proc_name,\n    nspp.nspname proc_schema,\n    tg.tgenabled enabled,\n    tg.oid in (select * from extension_oids) as extension_owned\nfrom pg_trigger tg\njoin pg_class cls on cls.oid = tg.tgrelid\njoin pg_namespace nsp on nsp.oid = cls.relnamespace\njoin pg_proc proc on proc.oid = tg.tgfoid\njoin pg_namespace nspp on nspp.oid = proc.pronamespace\nwhere not tg.tgisinternal\n-- SKIP_INTERNAL and not tg.oid in (select * from extension_oids)\norder by schema, table_name, name;\n",
  "types.sql": "with extension_oids as (\n  select\n      objid\n  from\n      pg_depend d\n  WHERE\n      d.refclassid = 'pg_extension'::regclass and\n      d.classid = 'pg_type'::regclass\n)\n\nSELECT\n  n.nspname AS schema,\n  pg_catalog.format_type (t.oid, NULL) AS name,\n  t.typname AS internal_name,\n  CASE\n    WHEN t.typrelid != 0\n      THEN CAST ( 'tuple' AS pg_catalog.text )\n    WHEN t.typlen < 0\n      THEN CAST ( 'var' AS pg_catalog.text )\n    ELSE CAST ( t.typlen AS pg_catalog.text )\n  END AS size,\n  -- pg_catalog.array_to_string (\n  --   ARRAY(\n  --     SELECT e.enumlabel\n  --       FROM pg_catalog.pg_enum e\n  --       WHERE e.enumtypid = t.oid\n  --       ORDER BY e.oid ), E'\\n'\n  --   ) AS columns,\n  pg_catalog.obj_description (t.oid, 'pg_type') AS description,\n  (array_to_json(array(\n    select\n      jsonb_build_object('attribute', attname, 'type', a.typname)\n    from pg_class\n    join pg_attribute on (attrelid = pg_class.oid)\n    join pg_type a on (atttypid = a.oid)\n    where (pg_class.reltype = t.oid)\n  ))) as columns\nFROM\n  pg_catalog.pg_type t\n  LEFT JOIN pg_catalog.pg_namespace n\n    ON n.oid = t.typnamespace\nWHERE (\n  t.typrelid = 0\n  OR (\n    SELECT c.relkind = 'c'\n      FROM pg_catalog.pg_class c\n      WHERE c.oid = t.typrelid\n  )\n)\nAND NOT EXISTS (\n  SELECT 1\n    FROM pg_catalog.pg_type el\n    WHERE el.oid = t.typelem\n    AND el.typarray = t.oid\n)\nAND n.nspname <> 'pg_catalog'\nAND n.nspname <> 'information_schema'\nAND pg_catalog.pg_type_is_visible ( t.oid )\nand t.typcategory = 'C'\nand t.oid not in (select * from extension_oids)\nORDER BY 1, 2;\n"
}
// codegen:end
