import * as fsSyncer from 'fs-syncer'
import {test, beforeEach, expect, vi as jest} from 'vitest'
import * as typegen from '../src'
import {getPureHelper} from './helper'

export const {typegenOptions, logger, poolHelper: helper} = getPureHelper({__filename})

beforeEach(async () => {
  jest.resetAllMocks()

  await helper.setupDb()
  await helper.pool.query(helper.sql`
    create table test_table1(
      a int not null,
      b int
    );
  `)
})

test('explicitly check a column for nullability', async () => {
  const syncer = fsSyncer.testFixture({
    expect,
    targetState: {
      'index.ts': `
        import {sql} from 'slonik'

        export default [
          sql\`
            select distinct
            e.enumtypid,
            t.typname,
            e.enumlabel,
            t.typnamespace::regnamespace::text as schema_name,
            e.enumsortorder,
            t.typnamespace::regnamespace::text = any(current_schemas(true)) as in_search_path,
            case
              when t.typnamespace::regnamespace::text = any(current_schemas(false))
                then quote_ident(t.typname)
              else
                quote_ident(t.typnamespace::regnamespace::text) || '.' || quote_ident(t.typname)
            end as searchable_type_name
          from
            pg_enum as e
          join
            pg_type as t
          on
            t.oid = e.enumtypid
          order by
            t.typnamespace::regnamespace::text,
            t.typname,
            e.enumsortorder
          \`
        ]
      `,
    },
  })

  syncer.sync()

  await typegen.generate(typegenOptions(syncer.baseDir))

  expect(logger.warn).not.toHaveBeenCalled()
  expect(logger.error).not.toHaveBeenCalled()

  expect(syncer.yaml()).toMatchInlineSnapshot(`
    "---
    index.ts: |-
      import {sql} from 'slonik'

      export default [
        sql<queries.PgEnum_PgType>\`
          select distinct
          e.enumtypid,
          t.typname,
          e.enumlabel,
          t.typnamespace::regnamespace::text as schema_name,
          e.enumsortorder,
          t.typnamespace::regnamespace::text = any(current_schemas(true)) as in_search_path,
          case
            when t.typnamespace::regnamespace::text = any(current_schemas(false))
              then quote_ident(t.typname)
            else
              quote_ident(t.typnamespace::regnamespace::text) || '.' || quote_ident(t.typname)
          end as searchable_type_name
        from
          pg_enum as e
        join
          pg_type as t
        on
          t.oid = e.enumtypid
        order by
          t.typnamespace::regnamespace::text,
          t.typname,
          e.enumsortorder
        \`,
      ]

      export declare namespace queries {
        // Generated by @pgkit/typegen

        /** - query: \`select distinct e.enumtypid, t.typname, ... [truncated] ...espace::text, t.typname, e.enumsortorder\` */
        export interface PgEnum_PgType {
          /** regtype: \`oid\` */
          enumtypid: number | null

          /** regtype: \`name\` */
          typname: string | null

          /** regtype: \`name\` */
          enumlabel: string | null

          /** regtype: \`text\` */
          schema_name: string | null

          /** regtype: \`real\` */
          enumsortorder: number | null

          /** regtype: \`boolean\` */
          in_search_path: boolean | null

          /** regtype: \`text\` */
          searchable_type_name: string | null
        }
      }
    "
  `)
})
