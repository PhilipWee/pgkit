import {sql} from '@pgkit/client'
import {expectTypeOf} from 'expect-type'
import * as fs from 'fs'
import * as path from 'path'
import {test, beforeEach, expect, afterEach} from 'vitest'
import * as typegen from '../src'
import {getPureHelper as getHelper} from './helper'

export const {typegenOptions, logger, poolHelper: helper} = getHelper({__filename})

const modifyableFile = __filename + '.ignoreme.copy.ts'

beforeEach(async () => {
  fs.copyFileSync(__filename, modifyableFile)
  await helper.setupDb()
  await helper.pool.query(helper.sql`
    create table types_test_table(foo int primary key, bar text);

    insert into types_test_table(foo, bar) values (1, 'a')
  `)
})

afterEach(async () => {
  fs.unlinkSync(modifyableFile)
})

test('types are correct', async () => {
  // This test is stupidly meta. It modifies its own source code, then verifies the modified code is correct.
  // To be sure it's verifying the right thing, it ensures that the modification has already been done. - i.e. running
  // codegen has no effect. This means it necesssarily has to fail the very first time it's run.

  logger.warn.mockReset()
  await typegen.generate({
    ...typegenOptions(__dirname),
    include: [path.basename(modifyableFile)], // match only the copied file
  })

  const modifyableFileAfterRunning = fs.readFileSync(modifyableFile).toString()
  try {
    expect(modifyableFileAfterRunning).toEqual(fs.readFileSync(__filename).toString())
  } catch (e) {
    if (process.env.TYPEGEN_UPDATE_TEST_FILE) {
      fs.writeFileSync(__filename, modifyableFileAfterRunning)
    }
    e.message += `\n\nIf you want to update the test file, run this test with:\nTYPEGEN_UPDATE_TEST_FILE=1`
    throw e
  }

  const results = await helper.pool.query(sql<queries.TypesTestTable>`select * from types_test_table`)

  expect(results.rows).toHaveLength(1)
  expect(results.rows).toEqual([{foo: 1, bar: 'a'}])

  expectTypeOf(results.rows).items.toEqualTypeOf<{foo: number; bar: string | null}>()

  expect(logger.warn).toHaveBeenCalledTimes(1)
  // todo: fix this. I don't think we should be logging an error for a valid query that can't be typegen'd.
  expect(logger.warn.mock.calls[0][0].replaceAll(/\n\s+\n/g, '\n\n')).toMatchInlineSnapshot(`
    "Error: ./test/types.test.ts.ignoreme.copy.ts:16 [!] Query is not typeable.
      Caused by: Error: Walking AST failed for 
          create table types_test_table(foo int primary key, bar text);

          insert into types_test_table(foo, bar) values (1, 'a')

        Caused by: AssertionError [ERR_ASSERTION]: Can't parse query
        ---

            create table types_test_table(foo int primary key, bar text);

            insert into types_test_table(foo, bar) values (1, 'a')

        ---
        because it has 2 statements.
    "
  `)
})

export declare namespace queries {
  // Generated by @pgkit/typegen

  /** - query: `select * from types_test_table` */
  export interface TypesTestTable {
    /** column: `public.types_test_table.foo`, not null: `true`, regtype: `integer` */
    foo: number

    /** column: `public.types_test_table.bar`, regtype: `text` */
    bar: string | null
  }
}
